/**
 * Utility functions for the LLM Council System
 */

export interface CouncilStats {
    totalQueries: number;
    avgConsensusScore: number;
    avgResponseTime: number;
    totalDocuments: number;
    memberRating: Record<string, number>;
}

export interface QueryHistory {
    id: string;
    query: string;
    timestamp: Date;
    consensusScore: number;
    responseTime: number;
}

/**
 * Format milliseconds to human readable time
 */
export function formatTime(ms: number): string {
    if (ms < 1000) {
        return `${Math.round(ms)}ms`;
    }
    return `${(ms / 1000).toFixed(2)}s`;
}

/**
 * Format consensus score to percentage
 */
export function formatConsensusScore(score: number): string {
    return `${Math.round(score * 100)}%`;
}

/**
 * Determine confidence badge color based on score
 */
export function getConfidenceColor(confidence: number): string {
    if (confidence >= 0.8) return 'bg-green-100 text-green-800 border-green-300';
    if (confidence >= 0.6) return 'bg-blue-100 text-blue-800 border-blue-300';
    if (confidence >= 0.4) return 'bg-yellow-100 text-yellow-800 border-yellow-300';
    return 'bg-red-100 text-red-800 border-red-300';
}

/**
 * Determine consensus status based on score
 */
export function getConsensusStatus(score: number): string {
    if (score >= 0.85) return 'Strong Consensus';
    if (score >= 0.7) return 'Good Consensus';
    if (score >= 0.5) return 'Moderate Consensus';
    if (score >= 0.3) return 'Weak Consensus';
    return 'Disagreement';
}

/**
 * Extract member-specific insights
 */
export function extractMemberInsights(response: string): { insights: string[]; confidence: number } {
    const insightPatterns = [
        /important note[:\s]+(.*?)(?=\n|$)/gi,
        /key point[:\s]+(.*?)(?=\n|$)/gi,
        /critical insight[:\s]+(.*?)(?=\n|$)/gi
    ];

    const insights: string[] = [];
    for (const pattern of insightPatterns) {
        let match;
        while ((match = pattern.exec(response)) !== null) {
            insights.push(match[1].trim());
        }
    }

    const confidenceMatch = response.match(/confidence[:\s]+(\d+(?:\.\d+)?)\s*%/i);
    const confidence = confidenceMatch ? parseFloat(confidenceMatch[1]) / 100 : 0.7;

    return { insights, confidence };
}

/**
 * Sanitize user input
 */
export function sanitizeQuery(query: string): string {
    return query
        .trim()
        .slice(0, 5000) // Limit to 5000 characters
        .replace(/\n{3,}/g, '\n\n'); // Remove excessive newlines
}

/**
 * Check if API is available
 */
export async function checkCouncilHealth(): Promise<boolean> {
    try {
        const response = await fetch('http://localhost:4000/api/council/health');
        return response.ok;
    } catch {
        return false;
    }
}

/**
 * Export response as JSON
 */
export function exportAsJSON(data: any, filename: string = 'council-response.json'): void {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

/**
 * Export response as Markdown
 */
export function exportAsMarkdown(response: string, query: string, filename: string = 'council-response.md'): void {
    const markdown = `# Council Response

## Query
${query}

## Analysis
${response}

---
*Generated by XamSaDine AI Council*
*Timestamp: ${new Date().toISOString()}*
`;

    const blob = new Blob([markdown], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

/**
 * Parse CSV and upload as documents
 */
export async function parseCSVDocuments(csvContent: string): Promise<Array<{
    docId: string;
    title: string;
    content: string;
    source: string;
    category: string;
}>> {
    const lines = csvContent.split('\n');
    const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

    const documents = [];
    for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue;

        const values = lines[i].split(',').map(v => v.trim());
        const doc: any = {};

        headers.forEach((header, idx) => {
            doc[header] = values[idx] || '';
        });

        if (doc.docid && doc.title && doc.content) {
            documents.push({
                docId: doc.docid,
                title: doc.title,
                content: doc.content,
                source: doc.source || 'CSV Import',
                category: doc.category || 'general'
            });
        }
    }

    return documents;
}

/**
 * Calculate consensus metrics
 */
export function calculateConsensusMetrics(
    responses: Array<{ confidence: number; score?: number }>
): {
    avgConfidence: number;
    agreement: number;
    variance: number;
} {
    const confidences = responses.map(r => r.confidence);
    const avgConfidence = confidences.reduce((a, b) => a + b, 0) / confidences.length;

    const scores = responses.filter(r => r.score).map(r => r.score!);
    const avgScore = scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : 5;
    const agreement = Math.max(0, 1 - Math.abs(avgScore - 5) / 5);

    const variance = confidences.reduce((sum, c) => sum + Math.pow(c - avgConfidence, 2), 0) / confidences.length;

    return {
        avgConfidence,
        agreement,
        variance: Math.sqrt(variance)
    };
}

/**
 * Track API usage for cost estimation
 */
export interface APIUsageMetrics {
    modelRequests: Record<string, number>;
    totalTokens: Record<string, { prompt: number; completion: number }>;
    estimatedCost: number;
}

export function estimateCosts(
    members: Array<{ modelId: string }>,
    responseCount: number,
    avgTokens: number = 1500
): number {
    // Simplified cost estimation
    // In reality, would track actual token usage from API responses
    const costs: Record<string, number> = {
        'anthropic/claude-3-opus': 0.015, // per 1K prompt tokens
        'openai/gpt-4o': 0.005,
        'mistralai/mistral-large': 0.002,
        'meta-llama/llama-3-70b-instruct': 0.0008
    };

    let totalCost = 0;
    for (const member of members) {
        const costPer1K = costs[member.modelId] || 0.01;
        const tokensUsed = (avgTokens * responseCount) / 1000;
        totalCost += tokensUsed * costPer1K;
    }

    return totalCost;
}

/**
 * Generate analytics summary
 */
export function generateAnalyticsSummary(stats: CouncilStats): string {
    return `
ðŸ“Š LLM Council Analytics
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ˆ Total Queries: ${stats.totalQueries}
ðŸŽ¯ Avg Consensus Score: ${formatConsensusScore(stats.avgConsensusScore)}
â±ï¸  Avg Response Time: ${formatTime(stats.avgResponseTime)}
ðŸ“š Total Documents: ${stats.totalDocuments}

ðŸ‘¥ Member Performance:
${Object.entries(stats.memberRating)
    .map(([name, rating]) => `  ${name}: ${rating.toFixed(2)}/10`)
    .join('\n')}
    `;
}
